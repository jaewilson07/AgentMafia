[{"parts":[{"content":"add a tool for generating a python function that returns the mermaid diagram text","timestamp":"2025-04-01T18:48:10.146784Z","part_kind":"user-prompt"}],"kind":"request"},{"parts":[{"tool_name":"retrieve_relevant_documentation","args":"{\"user_query\": \"create a tool for generating a Python function that returns mermaid diagram text\"}","tool_call_id":"call_Rf5tk8foud4HAhEBodh932de","part_kind":"tool-call"},{"tool_name":"get_page_content","args":"{\"url\": \"https://ai.pydantic.dev/api/tools/\"}","tool_call_id":"call_a4NbOS4xrTT7JdvSLOPns7kj","part_kind":"tool-call"}],"model_name":"gpt-4o-mini-2024-07-18","timestamp":"2025-04-01T18:48:10Z","kind":"response"},{"parts":[{"tool_name":"retrieve_relevant_documentation","content":["# MermaidConfig Class\n\n```\n  \n---|---  \n###  MermaidConfig\nBases: `TypedDict[](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.TypedDict \"typing_extensions.TypedDict\")`\nParameters to configure mermaid chart generation.\nSource code in `pydantic_graph/pydantic_graph/mermaid.py`\n```\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n```\n| ```\nclassMermaidConfig(TypedDict, total=False):\n\"\"\"Parameters to configure mermaid chart generation.\"\"\"\n  start_node: Sequence[NodeIdent] | NodeIdent\n\"\"\"Identifiers of nodes that start the graph.\"\"\"\n  highlighted_nodes: Sequence[NodeIdent] | NodeIdent\n\"\"\"Identifiers of nodes to highlight.\"\"\"\n  highlight_css: str\n\"\"\"CSS to use for highlighting nodes.\"\"\"\n  title: str | None\n\"\"\"The title of the diagram.\"\"\"\n  edge_labels: bool\n\"\"\"Whether to include edge labels in the diagram.\"\"\"\n  notes: bool\n\"\"\"Whether to include notes on nodes in the diagram, defaults to true.\"\"\"\n  image_type: Literal['jpeg', 'png', 'webp', 'svg', 'pdf']\n\"\"\"The image type to generate. If unspecified, the default behavior is `'jpeg'`.\"\"\"\n  pdf_fit: bool\n\"\"\"When using image_type='pdf', whether to fit the diagram to the PDF page.\"\"\"\n  pdf_landscape: bool\n\"\"\"When using image_type='pdf', whether to use landscape orientation for the PDF.\n  This has no effect if using `pdf_fit`.\n  \"\"\"\n  pdf_paper: Literal['letter', 'legal', 'tabloid', 'ledger', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6']\n\"\"\"When using image_type='pdf', the paper size of the PDF.\"\"\"\n  background_color: str\n\"\"\"The background color of the diagram.\n  If None, the default transparent background is used. The color value is interpreted as a hexadecimal color\n  code by default (and should not have a leading '#'), but you can also use named colors by prefixing the\n  value with `'!'`. For example, valid choices include `background_color='!white'` or `background_color='FF0000'`.\n  \"\"\"\n  theme: Literal['default', 'neutral', 'dark', 'forest']\n\"\"\"The theme of the diagram. Defaults to 'default'.\"\"\"\n  width: int\n\"\"\"The width of the diagram.\"\"\"\n  height: int\n\"\"\"The height of the diagram.\"\"\"\n  scale: Annotated[float, Ge(1), Le(3)]\n\"\"\"The scale of the diagram.\n  The scale must be a number between 1 and 3, and you can only set a scale if one or both of width and height are set.\n  \"\"\"\n  httpx_client: httpx.Client\n\"\"\"An HTTPX client to use for requests, mostly for testing purposes.\"\"\"\n  direction: StateDiagramDirection\n\"\"\"The direction of the state diagram.\"\"\"\n\n```\n  \n---|---  \n####  start_node `instance-attribute`\n```\nstart_node: Sequence[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence \"collections.abc.Sequence\")[NodeIdent[](https://ai.pydantic.dev/api/pydantic_graph/mermaid/#pydantic_graph.mermaid.NodeIdent \"pydantic_graph.mermaid.NodeIdent\")] | NodeIdent[](https://ai.pydantic.dev/api/pydantic_graph/mermaid/#pydantic_graph.mermaid.NodeIdent \"pydantic_graph.mermaid.NodeIdent\")\n\n```\n\nIdentifiers of nodes that start the graph.\n####  highlighted_nodes `instance-attribute`\n```\nhighlighted_nodes: Sequence[](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence \"collections.abc.Sequence\")[NodeIdent[](https://ai.pydantic.dev/api/pydantic_graph/mermaid/#pydantic_graph.mermaid.NodeIdent \"pydantic_graph.mermaid.NodeIdent\")] | NodeIdent[](https://ai.pydantic.dev/api/pydantic_graph/mermaid/#pydantic_graph.mermaid.NodeIdent \"pydantic_graph.mermaid.NodeIdent\")\n\n```\n\nIdentifiers of nodes to highlight.\n####  highlight_css `instance-attribute`\n```\nhighlight_css: str[](https://docs.python.org/3/library/stdtypes.html#str)\n\n```\n\nCSS to use for highlighting nodes.\n####  title `instance-attribute`\n```\ntitle: str[](https://docs.python.org/3/library/stdtypes.html#str) | None\n\n```\n\nThe title of the diagram.\n####  edge_labels `instance-attribute`\n```\nedge_labels: bool[](https://docs.python.org/3/library/functions.html#bool)\n\n```\n\nWhether to include edge labels in the diagram.\n####  notes `instance-attribute`\n```\nnotes: bool[](https://docs.python.org/3/library/functions.html#bool)\n\n```\n\nWhether to include notes on nodes in the diagram, defaults to true.\n####  image_type `instance-attribute`\n```\nimage_type: Literal[](https://docs.python.org/3/library/typing.html#typing.Literal \"typing.Literal\")['jpeg', 'png', 'webp', 'svg', 'pdf']\n\n```\n\nThe image type to generate. If unspecified, the default behavior is `'jpeg'`.\n####  pdf_fit `instance-attribute`\n```\npdf_fit: bool[](https://docs.python.org/3/library/functions.html#bool)\n\n```\n\nWhen using image_type='pdf', whether to fit the diagram to the PDF page.\n####  pdf_landscape `instance-attribute`\n```\npdf_landscape: bool[](https://docs.python.org/3/library/functions.html#bool)\n\n```\n\nWhen using image_type='pdf', whether to use landscape orientation for the PDF.\nThis has no effect if using `pdf_fit`.\n####  pdf_paper `instance-attribute`","# PDF Paper Size and Diagram Attributes in Pydantic\n\n```\npdf_paper: Literal[](https://docs.python.org/3/library/typing.html#typing.Literal \"typing.Literal\")[\n  \"letter\",\n  \"legal\",\n  \"tabloid\",\n  \"ledger\",\n  \"a0\",\n  \"a1\",\n  \"a2\",\n  \"a3\",\n  \"a4\",\n  \"a5\",\n  \"a6\",\n]\n\n```\n\nWhen using image_type='pdf', the paper size of the PDF.\n####  background_color `instance-attribute`\n```\nbackground_color: str[](https://docs.python.org/3/library/stdtypes.html#str)\n\n```\n\nThe background color of the diagram.\nIf None, the default transparent background is used. The color value is interpreted as a hexadecimal color code by default (and should not have a leading '#'), but you can also use named colors by prefixing the value with `'!'`. For example, valid choices include `background_color='!white'` or `background_color='FF0000'`.\n####  theme `instance-attribute`\n```\ntheme: Literal[](https://docs.python.org/3/library/typing.html#typing.Literal \"typing.Literal\")['default', 'neutral', 'dark', 'forest']\n\n```\n\nThe theme of the diagram. Defaults to 'default'.\n####  width `instance-attribute`\n```\nwidth: int[](https://docs.python.org/3/library/functions.html#int)\n\n```\n\nThe width of the diagram.\n####  height `instance-attribute`\n```\nheight: int[](https://docs.python.org/3/library/functions.html#int)\n\n```\n\nThe height of the diagram.\n####  scale `instance-attribute`\n```\nscale: Annotated[](https://docs.python.org/3/library/typing.html#typing.Annotated \"typing.Annotated\")[float[](https://docs.python.org/3/library/functions.html#float), Ge(1), Le(3)]\n\n```\n\nThe scale of the diagram.\nThe scale must be a number between 1 and 3, and you can only set a scale if one or both of width and height are set.\n####  httpx_client `instance-attribute`\n```\nhttpx_client: Client\n\n```\n\nAn HTTPX client to use for requests, mostly for testing purposes.\n####  direction `instance-attribute`\n```\ndirection: StateDiagramDirection[](https://ai.pydantic.dev/api/pydantic_graph/mermaid/#pydantic_graph.mermaid.StateDiagramDirection \"pydantic_graph.mermaid.StateDiagramDirection\")\n\n```\n\nThe direction of the state diagram.\n###  NodeIdent `module-attribute`\n```\nNodeIdent: TypeAlias[](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.TypeAlias \"typing_extensions.TypeAlias\") = (\n  \"type[BaseNode[Any, Any, Any]] | BaseNode[Any, Any, Any] | str\"\n)\n\n```\n\nA type alias for a node identifier.\nThis can be:\n  * A node instance (instance of a subclass of [`BaseNode`](https://ai.pydantic.dev/api/pydantic_graph/nodes/#pydantic_graph.nodes.BaseNode)).\n  * A node class (subclass of [`BaseNode`](https://ai.pydantic.dev/api/pydantic_graph/nodes/#pydantic_graph.nodes.BaseNode)).\n  * A string representing the node ID.\n\n\n© Pydantic Services Inc. 2024 to present","# Weather Service Agent Implementation\n\n```\nimportasyncio\nfromdataclassesimport dataclass\nfromdatetimeimport date\nfrompydantic_aiimport Agent\nfrompydantic_ai.messagesimport (\n  FinalResultEvent,\n  FunctionToolCallEvent,\n  FunctionToolResultEvent,\n  PartDeltaEvent,\n  PartStartEvent,\n  TextPartDelta,\n  ToolCallPartDelta,\n)\nfrompydantic_ai.toolsimport RunContext\n\n@dataclass\nclassWeatherService:\n  async defget_forecast(self, location: str, forecast_date: date) -> str:\n    # In real code: call weather API, DB queries, etc.\n    return f'The forecast in {location} on {forecast_date} is 24°C and sunny.'\n  async defget_historic_weather(self, location: str, forecast_date: date) -> str:\n    # In real code: call a historical weather API or DB\n    return (\n      f'The weather in {location} on {forecast_date} was 18°C and partly cloudy.'\n    )\n\nweather_agent = Agent[WeatherService, str](\n  'openai:gpt-4o',\n  deps_type=WeatherService,\n  result_type=str, # We'll produce a final answer as plain text\n  system_prompt='Providing a weather forecast at the locations the user provides.',\n)\n\n@weather_agent.tool\nasync defweather_forecast(\n  ctx: RunContext[WeatherService],\n  location: str,\n  forecast_date: date,\n) -> str:\n  if forecast_date >= date.today():\n    return await ctx.deps.get_forecast(location, forecast_date)\n  else:\n    return await ctx.deps.get_historic_weather(location, forecast_date)\n\noutput_messages: list[str] = []\n\nasync defmain():\n  user_prompt = 'What will the weather be like in Paris on Tuesday?'\n  # Begin a node-by-node, streaming iteration\n  async with weather_agent.iter(user_prompt, deps=WeatherService()) as run:\n    async for node in run:\n      if Agent.is_user_prompt_node(node):\n        # A user prompt node => The user has provided input\n        output_messages.append(f'=== UserPromptNode: {node.user_prompt} ===')\n      elif Agent.is_model_request_node(node):\n        # A model request node => We can stream tokens from the model's request\n        output_messages.append(\n          '=== ModelRequestNode: streaming partial request tokens ==='\n        )\n        async with node.stream(run.ctx) as request_stream:\n          async for event in request_stream:\n            if isinstance(event, PartStartEvent):\n              output_messages.append(\n                f'[Request] Starting part {event.index}: {event.part!r}'\n              )\n            elif isinstance(event, PartDeltaEvent):\n              if isinstance(event.delta, TextPartDelta):\n                output_messages.append(\n                  f'[Request] Part {event.index} text delta: {event.delta.content_delta!r}'\n                )\n              elif isinstance(event.delta, ToolCallPartDelta):\n                output_messages.append(\n                  f'[Request] Part {event.index} args_delta={event.delta.args_delta}'\n                )\n            elif isinstance(event, FinalResultEvent):\n              output_messages.append(\n                f'[Result] The model produced a final result (tool_name={event.tool_name})'\n              )\n      elif Agent.is_call_tools_node(node):\n        # A handle-response node => The model returned some data, potentially calls a tool\n        output_messages.append(\n          '=== CallToolsNode: streaming partial response & tool usage ==='\n        )\n        async with node.stream(run.ctx) as handle_stream:\n          async for event in handle_stream:\n            if isinstance(event, FunctionToolCallEvent):\n              output_messages.append(\n                f'[Tools] The LLM calls tool={event.part.tool_name!r} with args={event.part.args} (tool_call_id={event.part.tool_call_id!r})'\n              )\n            elif isinstance(event, FunctionToolResultEvent):\n              output_messages.append(\n                f'[Tools] Tool call {event.tool_call_id!r} returned => {event.result.content}'\n              )\n      elif Agent.is_end_node(node):\n        assert run.result.data == node.data.data\n        # Once an End node is reached, the agent run is complete\n        output_messages.append(f'=== Final Agent Output: {run.result.data} ===')"],"tool_call_id":"call_Rf5tk8foud4HAhEBodh932de","timestamp":"2025-04-01T18:48:15.503315Z","part_kind":"tool-return"},{"tool_name":"get_page_content","content":[],"tool_call_id":"call_a4NbOS4xrTT7JdvSLOPns7kj","timestamp":"2025-04-01T18:48:12.347733Z","part_kind":"tool-return"}],"kind":"request"},{"parts":[{"content":"Here's how to add a tool in your AI agent that generates a Python function for returning the `mermaid.js` diagram text based on a process description.\n\n### 1. Update `agent_tools.py`\nYou will need to add an additional tool to generate a Python function that returns the generated diagram text.\n\n```python\nfrom typing import Any, Dict\nfrom pydantic_graph.mermaid import MermaidConfig\n\nasync def generate_mermaid_diagram(description: str) -> str:\n    # Transform the natural language description into mermaid.js syntax\n    config = MermaidConfig(\n        title='Generated Diagram',\n        start_node=[{'id': 'Start', 'label': 'Start Process'}],\n        edge_labels=True,\n        notes=True,\n        width=800,\n        height=600,\n    )\n    \n    # Process the description and convert it to mermaid syntax\n    mermaid_syntax = f\"\"\"\n    graph TD;\n        A[Start] --> B[Process {description}];\n        B --> C[End];\n    \"\"\"\n    \n    return mermaid_syntax\n\nasync def generate_python_function(description: str) -> str:\n    # Generates a Python function that returns the mermaid diagram text\n    mermaid_function = f\"\"\"\ndef get_mermaid_diagram():\n    return '''graph TD;\n        A[Start] --> B[Process {description}];\n        B --> C[End];\n    '''\n\"\"\"\n\n    return mermaid_function\n```\n\n### 2. Update `agent.py`\nNow, incorporate this new tool into your agent implementation.\n\n```python\nimport asyncio\nfrom typing import Any\nfrom dataclasses import dataclass\nfrom pydantic_ai import Agent\nfrom pydantic_ai.messages import FinalResultEvent\nfrom pydantic_ai.tools import RunContext\nfrom agent_tools import generate_mermaid_diagram, generate_python_function\n\n@dataclass\nclass DiagramService:\n    async def create_diagram(self, description: str) -> str:\n        return await generate_mermaid_diagram(description)\n\n    async def create_function(self, description: str) -> str:\n        return await generate_python_function(description)\n\ndiagram_agent = Agent[DiagramService, str](\n    'openai:gpt-4o',\n    deps_type=DiagramService,\n    result_type=str,\n    system_prompt='Generate a mermaid.js diagram from the provided process description.',\n)\n\n@diagram_agent.tool\nasync def create_mermaid_diagram(\n    ctx: RunContext[DiagramService],\n    description: str,\n) -> str:\n    return await ctx.deps.create_diagram(description)\n\n@diagram_agent.tool\nasync def create_python_function(\n    ctx: RunContext[DiagramService],\n    description: str,\n) -> str:\n    return await ctx.deps.create_function(description)\n\nasync def main():\n    user_prompt = 'Create a flowchart that shows the process of photosynthesis.'\n    async with diagram_agent.iter(user_prompt, deps=DiagramService()) as run:\n        async for node in run:\n            if Agent.is_end_node(node):\n                print(f'=== Final Diagram Output: {run.result.data} ===')\n```\n\n### Conclusion\nThe `generate_python_function` tool creates a Python function that returns the `mermaid.js` diagram for a given description. You can call this tool just like the `create_mermaid_diagram` tool, allowing users to get both the diagram text and the function definition in a single interaction.","part_kind":"text"}],"model_name":"gpt-4o-mini-2024-07-18","timestamp":"2025-04-01T18:48:15Z","kind":"response"}]